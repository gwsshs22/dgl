import os
from enum import Enum

DGL_INFER_MASTER_HOST = "DGL_INFER_MASTER_HOST"
DGL_INFER_MASTER_PORT = "DGL_INFER_MASTER_PORT"
DGL_INFER_MASTER_TORCH_PORT = "DGL_INFER_MASTER_TORCH_PORT"
DGL_INFER_NODE_RANK = "DGL_INFER_NODE_RANK"
DGL_INFER_LOCAL_RANK = "DGL_INFER_LOCAL_RANK"
DGL_INFER_NUM_NODES = "DGL_INFER_NUM_NODES"
DGL_INFER_NUM_BACKUP_SERVERS = "DGL_INFER_NUM_BACKUP_SERVERS"
DGL_INFER_NUM_DEVICES_PER_NODE = "DGL_INFER_NUM_DEVICES_PER_NODE"
DGL_INFER_NUM_SAMPLERS_PER_NODE = "DGL_INFER_NUM_SAMPLERS_PER_NODE"
DGL_INFER_IFACE = "DGL_INFER_IFACE"
DGL_INFER_RANDOM_SEED = "DGL_INFER_RANDOM_SEED"
DGL_INFER_ACTOR_PROCESS_ROLE = "DGL_INFER_ACTOR_PROCESS_ROLE"
DGL_INFER_ACTOR_PROCESS_GLOBAL_ID = "DGL_INFER_ACTOR_PROCESS_GLOBAL_ID"
DGL_INFER_IP_CONFIG_PATH = "DGL_INFER_IP_CONFIG_PATH"
DGL_INFER_GRAPH_NAME = "DGL_INFER_GRAPH_NAME"
DGL_INFER_GRAPH_CONFIG_PATH = "DGL_INFER_GRAPH_CONFIG_PATH"

DGL_INFER_PARALLELIZATION_TYPE = "DGL_INFER_PARALLELIZATION_TYPE"
DGL_INFER_USING_PRECOMPUTED_AGGREGATIONS = "DGL_INFER_USING_PRECOMPUTED_AGGREGATIONS"
DGL_INFER_PRECOM_FILENAME = "DGL_INFER_PRECOM_FILENAME"
DGL_INFER_MODEL_TYPE = "DGL_INFER_MODEL_TYPE"

DGL_INFER_MODEL_TYPE = "DGL_INFER_MODEL_TYPE"
DGL_INFER_NUM_LAYERS = "DGL_INFER_NUM_LAYERS"
DGL_INFER_FANOUTS = "DGL_INFER_FANOUTS"
DGL_INFER_NUM_INPUTS = "DGL_INFER_NUM_INPUTS"
DGL_INFER_NUM_HIDDENS = "DGL_INFER_NUM_HIDDENS"
DGL_INFER_NUM_OUTPUTS = "DGL_INFER_NUM_OUTPUTS"
DGL_INFER_HEADS = "DGL_INFER_HEADS"

DGL_INFER_INPUT_TRACE_DIR = "DGL_INFER_INPUT_TRACE_DIR"
DGL_INFER_NUM_WARMUPS =  "DGL_INFER_NUM_WARMUPS"
DGL_INFER_NUM_REQUESTS =  "DGL_INFER_NUM_REQUESTS"
DGL_INFER_RESULT_DIR = "DGL_INFER_RESULT_DIR"
DGL_INFER_COLLECT_STATS = "DGL_INFER_COLLECT_STATS"
DGL_INFER_EXECUTE_ONE_BY_ONE = "DGL_INFER_EXECUTE_ONE_BY_ONE"

DGL_INFER_EXP_LAMBDA = "DGL_INFER_EXP_LAMBDA"

class ParallelizationType(Enum):
    DATA = 0
    P3 = 1
    VERTEX_CUT = 2

def get_parallelization_type():
    ptype = int(os.environ[DGL_INFER_PARALLELIZATION_TYPE])
    if ptype == 0:
        return ParallelizationType.DATA
    elif ptype == 1:
        return ParallelizationType.P3
    else:
        return ParallelizationType.VERTEX_CUT

def get_using_precomputed_aggregations():
    s = os.environ[DGL_INFER_USING_PRECOMPUTED_AGGREGATIONS]
    if s == "0":
        return False
    elif s == "1":
        return True
    else:
        print(f"Unknown DGL_INFER_USING_PRECOMPUTED_AGGREGATIONS={DGL_INFER_USING_PRECOMPUTED_AGGREGATIONS}. It should be 0 or 1")

def get_collect_stats():
    s = os.environ[DGL_INFER_COLLECT_STATS]
    if s == "0":
        return False
    elif s == "1":
        return True
    else:
        print(f"Unknown DGL_INFER_COLLECT_STATS={DGL_INFER_COLLECT_STATS}. It should be 0 or 1")

def get_execute_one_by_one():
    s = os.environ[DGL_INFER_EXECUTE_ONE_BY_ONE]
    if s == "0":
        return False
    elif s == "1":
        return True
    else:
        print(f"Unknown DGL_INFER_EXECUTE_ONE_BY_ONE={DGL_INFER_EXECUTE_ONE_BY_ONE}. It should be 0 or 1")